H, W, K = map(int, input().split())
S = [input() for _ in range(H)]

ans = 0
# すでに訪れたマスを記録する配列
visited = [[False] * W for _ in range(H)]


# k 回移動してマス (i, j) にいる状態から探索を開始する
def rec(i, j, k):
    global ans
    if k == K:
        # K 回移動することができたら，答えに 1 を足して探索を終了
        ans += 1
        return
    # (i, j) を訪問済として記録する
    visited[i][j] = True
    # 隣接する 4 マスへの移動を試す
    for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
        ni, nj = i + di, j + dj
        # 移動先がマス目の中にあり，空きマスであり，まだ訪れていないならば，そこへ移動し再帰的に探索する
        if 0 <= ni < H and 0 <= nj < W and S[ni][nj] == "." and not visited[ni][nj]:
            rec(ni, nj, k + 1)
    # (i, j) を訪れなかったことにする
    visited[i][j] = False


# (i0, j0) をすべて試す
for i in range(H):
    for j in range(W):
        if S[i][j] == ".":
            rec(i, j, 0)
print(ans)


# まず，条件を満たす経路の個数を見積もってみましょう．
# (x0 ,y0) の選び方：たかだかHW 通り
# (x1 ,y1) の選び方：(x0 ,y0) の上下左右に隣接しているマスから選ばれるから，たかだか4通り
# (xk ,yk)(2≤k≤K) の選び方：(xk−1 ,yk−1) の上下左右に隣接しているたかだか4マスのうち，
#     (xk−2 ,yk−2) と異なるマスから選ばれるから，たかだか3通り
# 以上を合わせて，条件を満たす経路の個数はHW×4×3K−1≤2.3×107です．このくらいであれば，
# 可能な経路をすべて列挙しても実行時間制限に間に合います．可能な経路の列挙は， 深さ優先探索
# を使うのが便利です．（現在の位置，移動回数，すでに訪れたマス）の状態を持っておいて，次に移動
# できる場所をすべて試して再帰的に計算することで，経路を列挙することができます．
